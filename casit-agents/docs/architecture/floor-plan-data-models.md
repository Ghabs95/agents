# Floor Plan Editor - Data Models & Schemas

**Document Version:** 1.0  
**Date:** 2026-02-15  
**Owner:** @Architect  
**Related:** [ADR-001](./ADR-001-floor-plan-editor-architecture.md), [Issue #4](https://github.com/Ghabs95/agents/issues/4)

---

## Overview

This document defines the data models and schemas for the Floor Plan Editor feature across the Case Italia ecosystem:
- **Flutter App (casit-app):** Dart models for state management
- **Backend API (casit-be):** Python models for persistence
- **Data Flow:** JSON serialization contracts between layers

---

## 1. Flutter/Dart Data Models (casit-app)

### 1.1 FloorPlan Entity

```dart
// lib/models/floor_plan/floor_plan.dart
import 'package:equatable/equatable.dart';
import 'package:json_annotation/json_annotation.dart';

part 'floor_plan.g.dart';

@JsonSerializable()
class FloorPlan extends Equatable {
  final String id;
  final String propertyId;
  final String name;
  final List<Room> rooms;
  final List<Corner> corners;
  final List<Door> doors;
  final List<Window> windows;
  final Map<String, dynamic> metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String? svgUrl; // Firebase Storage URL
  
  const FloorPlan({
    required this.id,
    required this.propertyId,
    required this.name,
    required this.rooms,
    required this.corners,
    required this.doors,
    required this.windows,
    this.metadata = const {},
    required this.createdAt,
    required this.updatedAt,
    this.svgUrl,
  });
  
  FloorPlan copyWith({
    String? id,
    String? propertyId,
    String? name,
    List<Room>? rooms,
    List<Corner>? corners,
    List<Door>? doors,
    List<Window>? windows,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
    DateTime? updatedAt,
    String? svgUrl,
  }) {
    return FloorPlan(
      id: id ?? this.id,
      propertyId: propertyId ?? this.propertyId,
      name: name ?? this.name,
      rooms: rooms ?? this.rooms,
      corners: corners ?? this.corners,
      doors: doors ?? this.doors,
      windows: windows ?? this.windows,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      svgUrl: svgUrl ?? this.svgUrl,
    );
  }
  
  factory FloorPlan.fromJson(Map<String, dynamic> json) => 
      _$FloorPlanFromJson(json);
  
  Map<String, dynamic> toJson() => _$FloorPlanToJson(this);
  
  @override
  List<Object?> get props => [
    id, propertyId, name, rooms, corners, doors, windows, 
    metadata, createdAt, updatedAt, svgUrl
  ];
}
```

### 1.2 Room Entity

```dart
// lib/models/floor_plan/room.dart
@JsonSerializable()
class Room extends Equatable {
  final String id;
  final String floorPlanId;
  final String name; // e.g., "Living Room", "Bedroom"
  final RoomType type;
  final List<Offset> vertices; // Polygon vertices (x, y coordinates)
  final double rotation; // Degrees (0-360)
  final RoomStyle style;
  final List<String> doorIds;
  final List<String> windowIds;
  final List<String> cornerIds; // Auto-generated corners near openings
  final double area; // Square meters (calculated)
  
  const Room({
    required this.id,
    required this.floorPlanId,
    required this.name,
    required this.type,
    required this.vertices,
    this.rotation = 0.0,
    required this.style,
    this.doorIds = const [],
    this.windowIds = const [],
    this.cornerIds = const [],
    this.area = 0.0,
  });
  
  factory Room.fromJson(Map<String, dynamic> json) => _$RoomFromJson(json);
  Map<String, dynamic> toJson() => _$RoomToJson(this);
  
  @override
  List<Object?> get props => [
    id, floorPlanId, name, type, vertices, rotation, 
    style, doorIds, windowIds, cornerIds, area
  ];
}

enum RoomType {
  livingRoom,
  bedroom,
  bathroom,
  kitchen,
  hallway,
  balcony,
  storage,
  other
}

@JsonSerializable()
class RoomStyle {
  final String fillColor; // Hex color
  final String strokeColor;
  final double strokeWidth;
  final double opacity;
  
  const RoomStyle({
    this.fillColor = '#E3F2FD',
    this.strokeColor = '#1976D2',
    this.strokeWidth = 2.0,
    this.opacity = 0.8,
  });
  
  factory RoomStyle.fromJson(Map<String, dynamic> json) => 
      _$RoomStyleFromJson(json);
  Map<String, dynamic> toJson() => _$RoomStyleToJson(this);
}
```

### 1.3 Corner Entity

```dart
// lib/models/floor_plan/corner.dart
@JsonSerializable()
class Corner extends Equatable {
  final String id;
  final String floorPlanId;
  final Offset position; // (x, y) in canvas coordinates
  final bool isAutoGenerated; // True if created by door/window placement
  final String? parentOpeningId; // Door or Window ID that created this corner
  final CornerType type;
  final double? value; // User-editable measurement value (e.g., distance from wall)
  final String? unit; // "cm", "m", "in", "ft"
  
  const Corner({
    required this.id,
    required this.floorPlanId,
    required this.position,
    this.isAutoGenerated = false,
    this.parentOpeningId,
    this.type = CornerType.standard,
    this.value,
    this.unit = 'cm',
  });
  
  factory Corner.fromJson(Map<String, dynamic> json) => _$CornerFromJson(json);
  Map<String, dynamic> toJson() => _$CornerToJson(this);
  
  @override
  List<Object?> get props => [
    id, floorPlanId, position, isAutoGenerated, 
    parentOpeningId, type, value, unit
  ];
}

enum CornerType {
  standard,      // Regular room corner
  openingEdge,   // Generated near door/window
  wallJoint,     // Where two walls meet
  snapPoint,     // Snapping target for drag operations
}
```

### 1.4 Door Entity

```dart
// lib/models/floor_plan/door.dart
@JsonSerializable()
class Door extends Equatable {
  final String id;
  final String floorPlanId;
  final String roomId;
  final Offset position; // Center point of door
  final double width; // In meters
  final double rotation; // Degrees (0-360)
  final DoorType type;
  final bool opensInward;
  final List<String> connectedCornerIds; // Auto-generated corners
  
  const Door({
    required this.id,
    required this.floorPlanId,
    required this.roomId,
    required this.position,
    required this.width,
    this.rotation = 0.0,
    required this.type,
    this.opensInward = true,
    this.connectedCornerIds = const [],
  });
  
  factory Door.fromJson(Map<String, dynamic> json) => _$DoorFromJson(json);
  Map<String, dynamic> toJson() => _$DoorToJson(this);
  
  @override
  List<Object?> get props => [
    id, floorPlanId, roomId, position, width, rotation, 
    type, opensInward, connectedCornerIds
  ];
}

enum DoorType {
  single,    // Standard single door
  double_,   // Double door (underscore to avoid keyword)
  sliding,   // Sliding door
  folding,   // Bi-fold door
  entrance,  // Main entrance door
}
```

### 1.5 Window Entity

```dart
// lib/models/floor_plan/window.dart
@JsonSerializable()
class Window extends Equatable {
  final String id;
  final String floorPlanId;
  final String roomId;
  final Offset position;
  final double width;
  final double height;
  final double rotation;
  final WindowType type;
  final List<String> connectedCornerIds;
  
  const Window({
    required this.id,
    required this.floorPlanId,
    required this.roomId,
    required this.position,
    required this.width,
    required this.height,
    this.rotation = 0.0,
    required this.type,
    this.connectedCornerIds = const [],
  });
  
  factory Window.fromJson(Map<String, dynamic> json) => _$WindowFromJson(json);
  Map<String, dynamic> toJson() => _$WindowToJson(this);
  
  @override
  List<Object?> get props => [
    id, floorPlanId, roomId, position, width, height, 
    rotation, type, connectedCornerIds
  ];
}

enum WindowType {
  standard,   // Regular window
  french,     // French window (floor to ceiling)
  bay,        // Bay window
  skylight,   // Roof window
}
```

---

## 2. Backend Python Models (casit-be)

### 2.1 FloorPlan Model

```python
# casit_be/models/floor_plan.py
from datetime import datetime
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field


class FloorPlanModel(BaseModel):
    """
    Floor plan entity for property surveying.
    Stores structured data in PostgreSQL/MongoDB.
    """
    id: str = Field(..., description="UUID of floor plan")
    property_id: str = Field(..., description="Reference to parent property")
    name: str = Field(..., description="Floor plan name (e.g., '1st Floor')")
    rooms: List[Dict[str, Any]] = Field(default_factory=list)
    corners: List[Dict[str, Any]] = Field(default_factory=list)
    doors: List[Dict[str, Any]] = Field(default_factory=list)
    windows: List[Dict[str, Any]] = Field(default_factory=list)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    svg_url: Optional[str] = Field(None, description="Firebase Storage URL for SVG export")
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": "fp_abc123xyz",
                "property_id": "prop_456def",
                "name": "Ground Floor",
                "rooms": [
                    {
                        "id": "room_001",
                        "name": "Living Room",
                        "type": "livingRoom",
                        "vertices": [{"x": 0, "y": 0}, {"x": 100, "y": 0}],
                        "area": 25.5
                    }
                ],
                "corners": [],
                "doors": [],
                "windows": [],
                "metadata": {"unit_system": "metric"},
                "svg_url": "https://firebase.storage/floor_plans/fp_abc123xyz.svg"
            }
        }


class FloorPlanCreateRequest(BaseModel):
    """Request model for creating a new floor plan."""
    property_id: str
    name: str
    rooms: List[Dict[str, Any]] = []
    corners: List[Dict[str, Any]] = []
    doors: List[Dict[str, Any]] = []
    windows: List[Dict[str, Any]] = []
    metadata: Dict[str, Any] = {}


class FloorPlanUpdateRequest(BaseModel):
    """Request model for updating an existing floor plan."""
    name: Optional[str] = None
    rooms: Optional[List[Dict[str, Any]]] = None
    corners: Optional[List[Dict[str, Any]]] = None
    doors: Optional[List[Dict[str, Any]]] = None
    windows: Optional[List[Dict[str, Any]]] = None
    metadata: Optional[Dict[str, Any]] = None
    svg_url: Optional[str] = None


class FloorPlanResponse(BaseModel):
    """Response model for floor plan API endpoints."""
    id: str
    property_id: str
    name: str
    rooms: List[Dict[str, Any]]
    corners: List[Dict[str, Any]]
    doors: List[Dict[str, Any]]
    windows: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    created_at: str  # ISO 8601 format
    updated_at: str
    svg_url: Optional[str] = None
```

---

## 3. Data Validation Rules

### 3.1 Client-Side Validation (Flutter)

```dart
// lib/validators/floor_plan_validators.dart
class FloorPlanValidators {
  static String? validateRoomName(String? value) {
    if (value == null || value.isEmpty) {
      return 'Room name is required';
    }
    if (value.length > 50) {
      return 'Room name must be less than 50 characters';
    }
    return null;
  }
  
  static String? validateCornerPosition(Offset position, Size canvasSize) {
    if (position.dx < 0 || position.dx > canvasSize.width ||
        position.dy < 0 || position.dy > canvasSize.height) {
      return 'Corner must be within canvas bounds';
    }
    return null;
  }
  
  static String? validateDoorWidth(double width) {
    // Italian standard door widths: 60-120 cm
    if (width < 0.6 || width > 1.2) {
      return 'Door width must be between 60-120 cm';
    }
    return null;
  }
  
  static bool canSnapToCorner(Offset dragPosition, Offset cornerPosition) {
    const snapRadius = 30.0; // pixels
    final distance = (dragPosition - cornerPosition).distance;
    return distance < snapRadius;
  }
}
```

### 3.2 Server-Side Validation (Python)

```python
# casit_be/validators/floor_plan_validators.py
from typing import Dict, Any, List
from pydantic import validator


class FloorPlanValidationRules:
    """Server-side validation rules for floor plan data."""
    
    @staticmethod
    def validate_room_vertices(vertices: List[Dict[str, float]]) -> bool:
        """
        Ensure room vertices form a valid polygon.
        - Minimum 3 vertices (triangle)
        - No self-intersecting edges
        """
        if len(vertices) < 3:
            raise ValueError("Room must have at least 3 vertices")
        
        # Check for duplicate vertices
        unique_vertices = {(v['x'], v['y']) for v in vertices}
        if len(unique_vertices) != len(vertices):
            raise ValueError("Room contains duplicate vertices")
        
        return True
    
    @staticmethod
    def validate_corner_parent(corner: Dict[str, Any], doors: List[Dict], windows: List[Dict]) -> bool:
        """
        Ensure auto-generated corners reference valid parent openings.
        """
        if corner.get('is_auto_generated'):
            parent_id = corner.get('parent_opening_id')
            if not parent_id:
                raise ValueError("Auto-generated corner must have parent_opening_id")
            
            all_opening_ids = [d['id'] for d in doors] + [w['id'] for w in windows]
            if parent_id not in all_opening_ids:
                raise ValueError(f"Invalid parent_opening_id: {parent_id}")
        
        return True
    
    @staticmethod
    def validate_total_area(rooms: List[Dict[str, Any]]) -> bool:
        """
        Ensure total floor plan area is reasonable (10-1000 m²).
        """
        total_area = sum(room.get('area', 0) for room in rooms)
        if total_area < 10 or total_area > 1000:
            raise ValueError(f"Total area {total_area} m² is outside valid range (10-1000)")
        
        return True
```

---

## 4. Data Serialization Examples

### 4.1 JSON Payload Example (Create Floor Plan)

```json
{
  "property_id": "prop_789xyz",
  "name": "Ground Floor - Villa Caserta",
  "rooms": [
    {
      "id": "room_living_001",
      "floor_plan_id": "fp_abc123",
      "name": "Soggiorno",
      "type": "livingRoom",
      "vertices": [
        {"x": 50, "y": 50},
        {"x": 250, "y": 50},
        {"x": 250, "y": 200},
        {"x": 50, "y": 200}
      ],
      "rotation": 0,
      "style": {
        "fill_color": "#E3F2FD",
        "stroke_color": "#1976D2",
        "stroke_width": 2.0,
        "opacity": 0.8
      },
      "door_ids": ["door_001"],
      "window_ids": ["window_001", "window_002"],
      "corner_ids": ["corner_001", "corner_002"],
      "area": 30.0
    }
  ],
  "doors": [
    {
      "id": "door_001",
      "floor_plan_id": "fp_abc123",
      "room_id": "room_living_001",
      "position": {"x": 150, "y": 50},
      "width": 0.9,
      "rotation": 0,
      "type": "single",
      "opens_inward": true,
      "connected_corner_ids": ["corner_001", "corner_002"]
    }
  ],
  "corners": [
    {
      "id": "corner_001",
      "floor_plan_id": "fp_abc123",
      "position": {"x": 120, "y": 50},
      "is_auto_generated": true,
      "parent_opening_id": "door_001",
      "type": "openingEdge",
      "value": 30.0,
      "unit": "cm"
    },
    {
      "id": "corner_002",
      "floor_plan_id": "fp_abc123",
      "position": {"x": 180, "y": 50},
      "is_auto_generated": true,
      "parent_opening_id": "door_001",
      "type": "openingEdge",
      "value": 30.0,
      "unit": "cm"
    }
  ],
  "windows": [
    {
      "id": "window_001",
      "floor_plan_id": "fp_abc123",
      "room_id": "room_living_001",
      "position": {"x": 50, "y": 100},
      "width": 1.2,
      "height": 1.5,
      "rotation": 90,
      "type": "standard",
      "connected_corner_ids": []
    }
  ],
  "metadata": {
    "unit_system": "metric",
    "scale": 1,
    "floor_level": 0,
    "created_by": "user_456",
    "version": 1
  }
}
```

---

## 5. Database Schema (Backend)

### 5.1 PostgreSQL Schema (Recommended)

```sql
-- Floor Plans Table
CREATE TABLE floor_plans (
    id VARCHAR(64) PRIMARY KEY,
    property_id VARCHAR(64) NOT NULL,
    name VARCHAR(100) NOT NULL,
    data JSONB NOT NULL, -- Stores rooms, corners, doors, windows
    metadata JSONB DEFAULT '{}',
    svg_url TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_floor_plans_property ON floor_plans(property_id);
CREATE INDEX idx_floor_plans_updated ON floor_plans(updated_at DESC);
CREATE INDEX idx_floor_plans_data ON floor_plans USING GIN(data);

-- Trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER floor_plans_updated_at_trigger
BEFORE UPDATE ON floor_plans
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

### 5.2 MongoDB Schema (Alternative)

```javascript
// MongoDB collection: floor_plans
{
  _id: ObjectId("..."),
  id: "fp_abc123",
  property_id: "prop_789xyz",
  name: "Ground Floor",
  data: {
    rooms: [...],
    corners: [...],
    doors: [...],
    windows: [...]
  },
  metadata: {
    unit_system: "metric",
    scale: 1
  },
  svg_url: "https://firebase.storage/...",
  created_at: ISODate("2026-02-15T14:00:00Z"),
  updated_at: ISODate("2026-02-15T14:30:00Z")
}

// Indexes
db.floor_plans.createIndex({ property_id: 1 });
db.floor_plans.createIndex({ updated_at: -1 });
db.floor_plans.createIndex({ "data.rooms.type": 1 });
```

---

## 6. Data Migration Strategy

**Scenario:** Existing properties have no floor plan data.

### 6.1 Migration Approach
1. **Backward Compatibility:** Floor plan is optional for existing properties
2. **Lazy Creation:** Floor plan created on first edit (not on property creation)
3. **Default State:** Empty floor plan with metadata initialized

### 6.2 Migration Script (if needed)

```python
# migrations/add_floor_plans_table.py
def upgrade():
    """Add floor_plans table and relationship to properties."""
    # Create floor_plans table (see SQL schema above)
    # Add optional floor_plan_id column to properties table (nullable)
    pass

def downgrade():
    """Rollback floor_plans table."""
    # Drop floor_plans table
    # Remove floor_plan_id column from properties
    pass
```

---

## 7. Version Control

**Schema Version:** 1.0  
**Breaking Change Policy:**
- Major version bump (2.0) if entity structure changes
- Minor version bump (1.1) if new optional fields added
- Patch version bump (1.0.1) for validation rule changes

**Future Considerations:**
- Multi-floor support (floors array instead of single floor_plan)
- 3D elevation data (height/z-axis)
- Furniture placement layer
- AI-powered room recognition from photos

---

## References

- [ADR-001: Floor Plan Editor Architecture](./ADR-001-floor-plan-editor-architecture.md)
- [API Contracts](./floor-plan-api-contracts.md)
- [Flutter JSON Serialization](https://docs.flutter.dev/data-and-backend/serialization/json)
- [Pydantic Models](https://docs.pydantic.dev/)

---

**Status:** ✅ Ready for Review  
**Next Steps:**
1. @BackendLead: Implement Python models and database migrations
2. @MobileLead: Generate Dart models with `json_serializable`
3. @QAGuard: Create test fixtures based on example payloads
